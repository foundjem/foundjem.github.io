<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LOG8371 SPE Quality | Armstrong website</title><link>https://foundjem.github.io/tags/log8371-spe-quality/</link><atom:link href="https://foundjem.github.io/tags/log8371-spe-quality/index.xml" rel="self" type="application/rss+xml"/><description>LOG8371 SPE Quality</description><generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Tue, 24 Oct 2023 00:00:00 +0000</lastBuildDate><image><url>https://foundjem.github.io/media/logo.svg</url><title>LOG8371 SPE Quality</title><link>https://foundjem.github.io/tags/log8371-spe-quality/</link></image><item><title>Software Quality Engineering</title><link>https://foundjem.github.io/teaching/quality-eng/</link><pubDate>Tue, 24 Oct 2023 00:00:00 +0000</pubDate><guid>https://foundjem.github.io/teaching/quality-eng/</guid><description>&lt;p>Concepts relevant to software quality, quality assurance and testing, quality engineering and quality planning. Anomaly prevention and defect classification. Fault tolerance. Software reliability engineering. Quality models. Comparison of different quality assurance techniques. Improving the software development process. Software and process. Identifying risks for quantifiable quality improvement.&lt;/p>
&lt;h2 id="lecture-notes--log8371">Lecture Notes ðŸ“š Log8371&lt;/h2>
&lt;p>ðŸ“¥ &lt;strong>Download PDF&lt;/strong>
&lt;a href="slides/01_Intro.pdf">Lec-01&lt;/a>,&amp;hellip; ,&lt;a href="slides/05_perf_eng.pdf">Lec-05&lt;/a>, &lt;a href="slides/06_perf_model.pdf">Lec-06&lt;/a>,&amp;hellip;, &lt;a href="slides/11_security_testing.pdf">Lec-11&lt;/a>, &lt;a href="slides/12_security_testing_2.pdf">Lec-12&lt;/a>,&amp;hellip;,&lt;a href="slides/14_Autoscaling.pdf">Lec-14&lt;/a>&lt;/p>
&lt;h2 id="outline">Outline&lt;/h2>
&lt;div class="markmap" style="height: 500px;">
&lt;pre>- LOG8371
- Module 1 (QualitÃ© fonctionnelle, FiabilitÃ©)
- ActivitÃ©s et processus de SQA
- Normes de qualitÃ©
- Assurance de qualitÃ© fonctionnelle
- Tests unitaires
- Tests automatiques
- DÃ©bogage
- Inspections, audits et revues
- VÃ©rification et validation
- IntÃ©gration continue
- Livraison continue
- Conflits de fusion
- Module 2 (EfficacitÃ©)
- Performance
- Profiling
- Monitoring
- Allocation des ressources
- ModÃ¨le de performance
- SystÃ¨mes auto-adaptatifs
- Autoscaling
- Module 3 (SÃ©curitÃ©)
- Tests de pÃ©nÃ©tration
- Mitigation des attaques
- Chaos Engineering
- SystÃ¨mes auto-rÃ©parateurs &lt;/pre>
&lt;/div>
&lt;h2 id="models">Models&lt;/h2>
&lt;div class="flex px-4 py-3 mb-6 rounded-md bg-primary-100 dark:bg-primary-900">
&lt;span class="pr-3 pt-1 text-primary-600 dark:text-primary-300">
&lt;svg height="24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">&lt;path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="m11.25 11.25l.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0a9 9 0 0 1 18 0m-9-3.75h.008v.008H12z"/>&lt;/svg>
&lt;/span>
&lt;span class="dark:text-neutral-300">Software Performance Engineering (SPE) relies on mathematical models to analyze, predict, and optimize system performance. Here are some commonly used mathematical models for software performance engineering problems:&lt;/span>
&lt;/div>
&lt;hr>
&lt;h2 id="queuing-theory-models">&lt;strong>Queuing Theory Models&lt;/strong>&lt;/h2>
&lt;p>Queuing models are widely used to represent software performance issues related to resource contention, response time, and throughput.&lt;/p>
&lt;h3 id="11-single-queue-model-mm1">&lt;strong>1.1 Single Queue Model (M/M/1)&lt;/strong>&lt;/h3>
&lt;p>Used for single-server systems where requests arrive randomly.&lt;/p>
&lt;ul>
&lt;li>\( \lambda \) = arrival rate (requests per second)&lt;/li>
&lt;li>\( \mu \) = service rate (requests per second)&lt;/li>
&lt;li>&lt;strong>Utilization&lt;/strong>:
\[
\rho = \frac{\lambda}{\mu}, \quad 0 \leq \rho &lt; 1
\]&lt;/li>
&lt;li>&lt;strong>Average number of requests in the system&lt;/strong>:
\[
L = \frac{\rho}{1 - \rho}
\]&lt;/li>
&lt;li>&lt;strong>Average response time&lt;/strong>:
\[
R = \frac{1}{\mu - \lambda}
\]&lt;/li>
&lt;/ul>
&lt;h3 id="12-multi-server-queuing-model-mmc">&lt;strong>1.2 Multi-server Queuing Model (M/M/c)&lt;/strong>&lt;/h3>
&lt;p>Used for systems with multiple processing units (e.g., web servers with multiple threads).&lt;/p>
&lt;ul>
&lt;li>\( c \) = number of servers&lt;/li>
&lt;li>&lt;strong>Utilization per server&lt;/strong>:
\[
\rho = \frac{\lambda}{c \cdot \mu}
\]&lt;/li>
&lt;li>&lt;strong>Probability that all servers are busy (Erlang-C formula)&lt;/strong>:
\[
P_0 = \left[ \sum_{n=0}^{c-1} \frac{(\lambda / \mu)^n}{n!} + \frac{(\lambda / \mu)^c}{c!(1 - \rho)} \right]^{-1}
\]&lt;/li>
&lt;li>&lt;strong>Expected response time&lt;/strong>:
\[
R = \frac{1}{\mu} + \frac{P_0 \cdot \rho}{c(1 - \rho) \mu}
\]&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-littles-law">&lt;strong>2. Littleâ€™s Law&lt;/strong>&lt;/h3>
\[
L = \lambda \times R
\]&lt;p>
Where:&lt;/p>
&lt;ul>
&lt;li>\( L \) = average number of requests in the system&lt;/li>
&lt;li>\( \lambda \) = arrival rate of requests&lt;/li>
&lt;li>\( R \) = response time&lt;/li>
&lt;/ul>
&lt;p>This law is often used to validate performance models and ensure consistency between measured and predicted values.&lt;/p>
&lt;hr>
&lt;h3 id="3-bottleneck-analysis-utilization-law">&lt;strong>3. Bottleneck Analysis (Utilization Law)&lt;/strong>&lt;/h3>
\[
U_i = X \times S_i
\]&lt;p>
Where:&lt;/p>
&lt;ul>
&lt;li>\( U_i \) = utilization of resource \( i \)&lt;/li>
&lt;li>\( X \) = system throughput (requests per second)&lt;/li>
&lt;li>\( S_i \) = average service time at resource \( i \)&lt;/li>
&lt;/ul>
\[
X_{\max} = \frac{1}{S_{\max}}
\]&lt;hr>
&lt;h3 id="4-scalability-model-amdahls-law">&lt;strong>4. Scalability Model (Amdahlâ€™s Law)&lt;/strong>&lt;/h3>
\[
S(p) = \frac{1}{(1 - \sigma) + \frac{\sigma}{p}}
\]&lt;p>
Where:&lt;/p>
&lt;ul>
&lt;li>\( S(p) \) = speedup with \( p \) processors&lt;/li>
&lt;li>\( \sigma \) = fraction of execution time that is parallelizable&lt;/li>
&lt;li>\( p \) = number of processors&lt;/li>
&lt;/ul>
&lt;p>For large \( p \), the speedup is limited by the non-parallelizable portion \( (1 - \sigma) \).&lt;/p>
&lt;hr>
&lt;h3 id="5-gunthers-universal-scalability-law-usl">&lt;strong>5. Guntherâ€™s Universal Scalability Law (USL)&lt;/strong>&lt;/h3>
\[
S(p) = \frac{p}{1 + \alpha(p - 1) + \beta p(p - 1)}
\]&lt;p>
Where:&lt;/p>
&lt;ul>
&lt;li>\( \alpha \) = contention factor (how much resources compete for shared resources)&lt;/li>
&lt;li>\( \beta \) = coherence penalty (overhead from synchronization)&lt;/li>
&lt;li>\( S(p) \) = speedup with \( p \) processors&lt;/li>
&lt;/ul>
&lt;p>This model helps predict performance degradation due to parallelism overhead.&lt;/p>
&lt;hr>
&lt;h3 id="6-response-time-model-mean-value-analysis">&lt;strong>6. Response Time Model (Mean Value Analysis)&lt;/strong>&lt;/h3>
\[
R_i = S_i \times (1 + N_i)
\]&lt;p>
Where:&lt;/p>
&lt;ul>
&lt;li>\( R_i \) = response time at resource \( i \)&lt;/li>
&lt;li>\( S_i \) = service time at resource \( i \)&lt;/li>
&lt;li>\( N_i \) = average number of requests in queue at resource \( i \)&lt;/li>
&lt;/ul>
\[
R_{\text{total}} = \sum_{i=1}^{n} R_i
\]&lt;hr>
&lt;h3 id="7-probabilistic-latency-model">&lt;strong>7. Probabilistic Latency Model&lt;/strong>&lt;/h3>
\[
E[R] = \sum_{i=1}^{n} P_i \times R_i
\]&lt;p>This is useful in microservices architectures where different services contribute to overall latency.&lt;/p>
&lt;hr>
&lt;h3 id="8-load-testing-model-throughput-and-concurrency">&lt;strong>8. Load Testing Model (Throughput and Concurrency)&lt;/strong>&lt;/h3>
\[
X = \frac{N}{R}
\]&lt;p>
Where:&lt;/p>
&lt;ul>
&lt;li>\( X \) = throughput (requests/sec)&lt;/li>
&lt;li>\( N \) = number of concurrent users&lt;/li>
&lt;li>\( R \) = response time&lt;/li>
&lt;/ul>
&lt;p>If load increases beyond system capacity, response time grows exponentially.&lt;/p>
&lt;hr>
&lt;h3 id="9-failure-rate-and-reliability-models">&lt;strong>9. Failure Rate and Reliability Models&lt;/strong>&lt;/h3>
\[
R(t) = e^{-\lambda t}
\]&lt;p>
Where:&lt;/p>
&lt;ul>
&lt;li>\( R(t) \) = reliability (probability the system runs without failure up to time \( t \))&lt;/li>
&lt;li>\( \lambda \) = failure rate&lt;/li>
&lt;/ul>
&lt;p>For software systems, failure rate often decreases over time as bugs are fixed.&lt;/p>
&lt;hr>
&lt;h3 id="10-cost-benefit-model-for-performance-optimization">&lt;strong>10. Cost-Benefit Model for Performance Optimization&lt;/strong>&lt;/h3>
\[
C_{\text{total}} = C_{\text{infra}} + C_{\text{latency}} + C_{\text{failure}}
\]&lt;p>
Where:&lt;/p>
&lt;ul>
&lt;li>\( C_{\text{infra}} \) = cost of additional hardware/cloud resources&lt;/li>
&lt;li>\( C_{\text{latency}} \) = lost revenue due to slow response time&lt;/li>
&lt;li>\( C_{\text{failure}} \) = downtime-related costs&lt;/li>
&lt;/ul>
&lt;p>Minimizing \( C_{\text{total}} \) ensures cost-effective performance improvements.&lt;/p>
&lt;hr>
&lt;h3 id="conclusion">&lt;strong>Conclusion&lt;/strong>&lt;/h3>
&lt;p>These mathematical models provide a foundation for analyzing and improving software performance. They help predict system behavior, identify bottlenecks, and optimize resources effectively. By applying these models, engineers can ensure software applications meet performance requirements efficiently.&lt;/p>
&lt;h2 id="pid-controller-in-software-performance-engineering">&lt;strong>PID Controller in Software Performance Engineering&lt;/strong>&lt;/h2>
&lt;p>A &lt;strong>Proportional-Integral-Derivative (PID) Controller&lt;/strong> is a feedback control mechanism widely used in software performance engineering for tasks such as &lt;strong>autoscaling, latency management, and resource allocation&lt;/strong>. It dynamically adjusts system parameters based on performance deviations.&lt;/p>
&lt;hr>
&lt;h2 id="1-pid-controller-equation">&lt;strong>1. PID Controller Equation&lt;/strong>&lt;/h2>
&lt;p>A PID controller computes the corrective action \( u(t) \) using three components: Proportional (P), Integral (I), and Derivative (D):&lt;/p>
\[
u(t) = K_p e(t) + K_i \int_{0}^{t} e(\tau) d\tau + K_d \frac{d}{dt} e(t)
\]&lt;p>Where:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>\( u(t) \) = control output (e.g., CPU allocation, number of servers)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\( e(t) \) = error between desired performance and actual performance:&lt;/p>
\[
e(t) = R_{\text{target}} - R_{\text{actual}}
\]&lt;/li>
&lt;li>
&lt;p>\( K_p \) = Proportional gain (adjusts based on immediate error)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\( K_i \) = Integral gain (adjusts based on accumulated past errors)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\( K_d \) = Derivative gain (adjusts based on predicted future errors)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\( R_{\text{target}} \) = target performance metric (e.g., response time)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>\( R_{\text{actual}} \) = actual observed performance metric&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="2-discrete-time-pid-controller">&lt;strong>2. Discrete-Time PID Controller&lt;/strong>&lt;/h2>
&lt;p>In software systems, performance metrics are sampled at discrete time intervals (\( k \)). The discrete PID formula is:&lt;/p>
\[
u_k = K_p e_k + K_i \sum_{i=0}^{k} e_i \Delta t + K_d \frac{e_k - e_{k-1}}{\Delta t}
\]&lt;p>Where:&lt;/p>
&lt;ul>
&lt;li>\( u_k \) = control output at time step \( k \)&lt;/li>
&lt;li>\( e_k \) = error at time step \( k \)&lt;/li>
&lt;li>\( \Delta t \) = sampling interval&lt;/li>
&lt;/ul>
&lt;p>In &lt;strong>discrete implementation&lt;/strong>, the integral is approximated as a sum:&lt;/p>
\[
I_k = I_{k-1} + e_k \Delta t
\]&lt;p>And the derivative as a difference:&lt;/p>
\[
D_k = \frac{e_k - e_{k-1}}{\Delta t}
\]&lt;p>Thus, the final control equation becomes:&lt;/p>
\[
u_k = K_p e_k + K_i I_k + K_d D_k
\]&lt;hr>
&lt;h2 id="3-application-in-software-performance-engineering">&lt;strong>3. Application in Software Performance Engineering&lt;/strong>&lt;/h2>
&lt;h3 id="autoscaling-for-cloud-resources">&lt;strong>Autoscaling for Cloud Resources&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Objective&lt;/strong>: Adjust the number of virtual machines (VMs) dynamically based on system load.&lt;/li>
&lt;li>&lt;strong>Error Signal&lt;/strong>: Difference between target response time and measured response time.&lt;/li>
&lt;li>&lt;strong>Control Output&lt;/strong>: Number of VMs to add or remove.&lt;/li>
&lt;/ul>
\[
\text{VMs}_{\text{new}} = \text{VMs}_{\text{current}} + u_k
\]&lt;h3 id="response-time-optimization">&lt;strong>Response Time Optimization&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Objective&lt;/strong>: Minimize response time in web applications.&lt;/li>
&lt;li>&lt;strong>Error Signal&lt;/strong>: Difference between target latency and actual latency.&lt;/li>
&lt;li>&lt;strong>Control Output&lt;/strong>: Request queue size limit or CPU allocation.&lt;/li>
&lt;/ul>
\[
\text{CPU}_{\text{new}} = \text{CPU}_{\text{current}} + u_k
\]&lt;h3 id="database-query-rate-limiting">&lt;strong>Database Query Rate Limiting&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Objective&lt;/strong>: Prevent overload on a database by controlling query rates.&lt;/li>
&lt;li>&lt;strong>Error Signal&lt;/strong>: Difference between allowed and actual queries per second.&lt;/li>
&lt;li>&lt;strong>Control Output&lt;/strong>: Maximum query rate.&lt;/li>
&lt;/ul>
\[
\text{Rate}_{\text{new}} = \text{Rate}_{\text{current}} + u_k
\]&lt;hr>
&lt;h2 id="4-choosing-pid-parameters">&lt;strong>4. Choosing PID Parameters&lt;/strong>&lt;/h2>
&lt;p>The effectiveness of a PID controller depends on tuning the parameters \( K_p, K_i, K_d \):&lt;/p>
&lt;ul>
&lt;li>&lt;strong>\( K_p \) (Proportional Gain)&lt;/strong>: Large values lead to &lt;strong>faster response&lt;/strong> but may cause instability.&lt;/li>
&lt;li>&lt;strong>\( K_i \) (Integral Gain)&lt;/strong>: Large values &lt;strong>reduce steady-state error&lt;/strong> but may cause overshoot.&lt;/li>
&lt;li>&lt;strong>\( K_d \) (Derivative Gain)&lt;/strong>: Large values help in &lt;strong>predicting future errors&lt;/strong> but may amplify noise.&lt;/li>
&lt;/ul>
&lt;h3 id="ziegler-nichols-tuning-method">&lt;strong>Ziegler-Nichols Tuning Method&lt;/strong>&lt;/h3>
&lt;p>A common method for tuning PID parameters:&lt;/p>
&lt;ol>
&lt;li>Set \( K_i = 0 \) and \( K_d = 0 \).&lt;/li>
&lt;li>Increase \( K_p \) until system oscillates (critical gain \( K_c \)).&lt;/li>
&lt;li>Find the oscillation period \( T_c \).&lt;/li>
&lt;li>Use tuning rules:&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Control Type&lt;/th>
&lt;th>\( K_p \)&lt;/th>
&lt;th>\( K_i \)&lt;/th>
&lt;th>\( K_d \)&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>P&lt;/td>
&lt;td>0.5 \( K_c \)&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PI&lt;/td>
&lt;td>0.45 \( K_c \)&lt;/td>
&lt;td>\( 1.2 K_c / T_c \)&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PID&lt;/td>
&lt;td>0.6 \( K_c \)&lt;/td>
&lt;td>\( 2 K_c / T_c \)&lt;/td>
&lt;td>\( K_c T_c / 8 \)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="5-stability-analysis-laplace-transform">&lt;strong>5. Stability Analysis (Laplace Transform)&lt;/strong>&lt;/h2>
&lt;p>The PID controller in Laplace domain is:&lt;/p>
\[
U(s) = (K_p + K_i \frac{1}{s} + K_d s) E(s)
\]&lt;p>The closed-loop system is:&lt;/p>
\[
G(s) = \frac{U(s) G_{\text{plant}}(s)}{1 + U(s) G_{\text{plant}}(s)}
\]&lt;p>The characteristic equation:&lt;/p>
\[
1 + (K_p + K_i \frac{1}{s} + K_d s) G_{\text{plant}}(s) = 0
\]&lt;p>Stability is determined using:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Root locus method&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Bode plot for frequency response&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Nyquist criterion&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="6-example-pid-for-autoscaling-web-servers">&lt;strong>6. Example: PID for Autoscaling Web Servers&lt;/strong>&lt;/h2>
&lt;p>&lt;strong>Given Data:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Target response time&lt;/strong>: \( R_{\text{target}} = 200ms \)&lt;/li>
&lt;li>&lt;strong>Measured response time&lt;/strong>: \( R_{\text{actual}} = 300ms \)&lt;/li>
&lt;li>&lt;strong>Sampling time&lt;/strong>: \( \Delta t = 5s \)&lt;/li>
&lt;li>&lt;strong>Initial number of servers&lt;/strong>: 10&lt;/li>
&lt;li>&lt;strong>PID Parameters&lt;/strong>: \( K_p = 1.5, K_i = 0.1, K_d = 0.5 \)&lt;/li>
&lt;/ul>
\[
e_k = R_{\text{target}} - R_{\text{actual}} = 200 - 300 = -100ms
\]\[
P_k = K_p \cdot e_k = 1.5 \cdot (-100) = -150
\]\[
I_k = I_{k-1} + K_i e_k \Delta t = 0 + 0.1 \times (-100) \times 5 = -50
\]\[
D_k = K_d \frac{e_k - e_{k-1}}{\Delta t} = 0.5 \frac{(-100) - (-50)}{5} = -5
\]\[
u_k = P_k + I_k + D_k = -150 - 50 - 5 = -205
\]\[
\text{Servers}_{\text{new}} = \text{Servers}_{\text{current}} + u_k = 10 - 2 = 8
\]&lt;p>If \( u_k \) is negative, it means reducing the number of servers.&lt;/p>
&lt;hr>
&lt;h2 id="7-conclusion">&lt;strong>7. Conclusion&lt;/strong>&lt;/h2>
&lt;p>The PID controller is a powerful tool in &lt;strong>software performance engineering&lt;/strong>, allowing dynamic resource management by &lt;strong>continuously adjusting&lt;/strong> system parameters. It is applied in:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Autoscaling cloud resources&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Latency and throughput optimization&lt;/strong>&lt;/li>
&lt;li>&lt;strong>Database rate limiting&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>By tuning the parameters correctly, it ensures that &lt;strong>performance targets are met&lt;/strong> while &lt;strong>avoiding oscillations and instability&lt;/strong>.&lt;/p>
&lt;h2 id="dynamic-layered-queuing-networks-lqn">&lt;strong>Dynamic Layered Queuing Networks (LQN)&lt;/strong>&lt;/h2>
&lt;h2 id="1-overview-of-dynamic-lqn">&lt;strong>1. Overview of Dynamic LQN&lt;/strong>&lt;/h2>
&lt;p>Layered Queuing Networks (LQNs) extend traditional queuing models to capture the interaction between multiple software and hardware layers, often representing client-server, microservices, and cloud-based architectures.&lt;/p>
&lt;p>A &lt;strong>Dynamic LQN (DLQN)&lt;/strong> incorporates time-varying workload, adaptive resource allocation, and system behavior changes over time. These models help predict performance bottlenecks, optimize system capacity, and adjust service strategies dynamically.&lt;/p>
&lt;hr>
&lt;h2 id="2-basic-mathematical-formulation-of-lqn">&lt;strong>2. Basic Mathematical Formulation of LQN&lt;/strong>&lt;/h2>
&lt;p>LQNs describe a system as a set of &lt;strong>tasks&lt;/strong> and &lt;strong>entries&lt;/strong>, where:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Tasks (\( T_i \))&lt;/strong> represent processing elements (e.g., database, application server).&lt;/li>
&lt;li>&lt;strong>Entries (\( E_i \))&lt;/strong> represent functions or operations executed within a task.&lt;/li>
&lt;li>&lt;strong>Calls (\( C_{ij} \))&lt;/strong> denote interactions between tasks.&lt;/li>
&lt;/ul>
&lt;p>Each task \( T_i \) has:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Arrival rate&lt;/strong> \( \lambda_i(t) \) (requests per second)&lt;/li>
&lt;li>&lt;strong>Service demand&lt;/strong> \( S_i(t) \) (time per request)&lt;/li>
&lt;li>&lt;strong>Queue discipline&lt;/strong> \( Q_i \) (e.g., FIFO, priority-based)&lt;/li>
&lt;/ul>
&lt;h3 id="queuing-equations-for-a-single-layer">&lt;strong>Queuing Equations for a Single Layer&lt;/strong>&lt;/h3>
\[
R_i = S_i + \frac{Q_i}{1 - \rho_i}
\]&lt;p>
where:&lt;/p>
&lt;ul>
&lt;li>\( \rho_i = \frac{\lambda_i S_i}{m_i} \) is the utilization of task \( T_i \) (with \( m_i \) parallel servers),&lt;/li>
&lt;li>\( Q_i \) is the waiting time due to other tasks.&lt;/li>
&lt;/ul>
\[
X_i = \frac{\lambda_i}{1 + \sum_{j \in C_{i}} P_{ij} R_j}
\]&lt;p>
where:&lt;/p>
&lt;ul>
&lt;li>\( P_{ij} \) is the probability that \( T_i \) calls \( T_j \),&lt;/li>
&lt;li>\( R_j \) is the response time of task \( j \).&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="3-dynamic-extension-of-lqn-dlqn">&lt;strong>3. Dynamic Extension of LQN (DLQN)&lt;/strong>&lt;/h2>
&lt;p>To model dynamic behavior, we introduce time-dependent parameters.&lt;/p>
&lt;h3 id="state-equations-in-dynamic-lqn">&lt;strong>State Equations in Dynamic LQN&lt;/strong>&lt;/h3>
\[
\frac{dN_i(t)}{dt} = \lambda_i(t) - \mu_i(t) N_i(t)
\]&lt;p>
where:&lt;/p>
&lt;ul>
&lt;li>\( N_i(t) \) is the number of requests in task \( i \) at time \( t \),&lt;/li>
&lt;li>\( \lambda_i(t) \) is the dynamic arrival rate,&lt;/li>
&lt;li>\( \mu_i(t) \) is the service rate.&lt;/li>
&lt;/ul>
&lt;h3 id="dynamic-resource-allocation">&lt;strong>Dynamic Resource Allocation&lt;/strong>&lt;/h3>
\[
m_i(t) = \max \left( 1, \frac{\lambda_i(t) S_i}{\rho_{\text{max}}} \right)
\]&lt;p>
where \( \rho_{\text{max}} \) is the maximum allowable utilization.&lt;/p>
\[
\mu_i(t) = \frac{m_i(t)}{S_i}
\]&lt;h3 id="dynamic-scaling">&lt;strong>Dynamic Scaling&lt;/strong>&lt;/h3>
\[
m_i(t+1) = m_i(t) + \Delta m_i
\]\[
\Delta m_i = k_p e(t) + k_i \int e(\tau) d\tau + k_d \frac{d e(t)}{dt}
\]&lt;p>
where \( e(t) = \rho_i - \rho_{\text{target}} \) and \( k_p, k_i, k_d \) are PID controller gains.&lt;/p>
&lt;hr>
&lt;h2 id="4-performance-metrics-in-dlqn">&lt;strong>4. Performance Metrics in DLQN&lt;/strong>&lt;/h2>
\[
R_{\text{sys}}(t) = \sum_{i=1}^{n} P_i R_i(t)
\]&lt;p>
where \( P_i \) is the probability that a request visits task \( i \).&lt;/p>
\[
U_i(t) = \frac{\lambda_i(t) S_i}{m_i(t)}
\]&lt;p>
where \( U_i(t) \leq 1 \) ensures the system does not overload.&lt;/p>
\[
X_{\text{sys}}(t) = \frac{\lambda_{\text{entry}}(t)}{1 + \sum_{i=1}^{n} P_i R_i(t)}
\]&lt;hr>
&lt;h2 id="5-example-dynamic-lqn-for-cloud-autoscaling">&lt;strong>5. Example: Dynamic LQN for Cloud Autoscaling&lt;/strong>&lt;/h2>
&lt;h3 id="scenario-web-application-with-3-tiers">&lt;strong>Scenario: Web Application with 3 Tiers&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Task 1&lt;/strong>: Load Balancer (\( T_1 \))&lt;/li>
&lt;li>&lt;strong>Task 2&lt;/strong>: Web Server (\( T_2 \))&lt;/li>
&lt;li>&lt;strong>Task 3&lt;/strong>: Database (\( T_3 \))&lt;/li>
&lt;/ul>
&lt;h3 id="step-1-define-arrival-rate">&lt;strong>Step 1: Define Arrival Rate&lt;/strong>&lt;/h3>
\[
\lambda_1(t) = \lambda_{\text{users}}(t)
\]&lt;h3 id="step-2-compute-response-time-per-layer">&lt;strong>Step 2: Compute Response Time per Layer&lt;/strong>&lt;/h3>
\[
R_1(t) = S_1 + \frac{Q_1}{1 - \rho_1}
\]\[
R_2(t) = S_2 + \frac{Q_2}{1 - \rho_2}
\]\[
R_3(t) = S_3 + \frac{Q_3}{1 - \rho_3}
\]&lt;h3 id="step-3-compute-system-response-time">&lt;strong>Step 3: Compute System Response Time&lt;/strong>&lt;/h3>
\[
R_{\text{sys}}(t) = R_1(t) + P_{12} R_2(t) + P_{23} R_3(t)
\]&lt;h3 id="step-4-adjust-resources-dynamically">&lt;strong>Step 4: Adjust Resources Dynamically&lt;/strong>&lt;/h3>
\[
\Delta m_2 = k_p e_2 + k_i \int e_2 d\tau + k_d \frac{d e_2}{dt}
\]&lt;p>where \( e_2 = \rho_2 - 0.8 \) ensures the web server operates below 80% utilization.&lt;/p>
&lt;h3 id="step-5-compute-throughput">&lt;strong>Step 5: Compute Throughput&lt;/strong>&lt;/h3>
\[
X_{\text{sys}}(t) = \frac{\lambda_1(t)}{1 + P_{12} R_2(t) + P_{23} R_3(t)}
\]&lt;hr>
&lt;h2 id="6-conclusion">&lt;strong>6. Conclusion&lt;/strong>&lt;/h2>
&lt;p>Dynamic LQN (DLQN) extends standard LQN models by incorporating &lt;strong>time-dependent queuing equations&lt;/strong>, &lt;strong>adaptive resource allocation&lt;/strong>, and &lt;strong>autoscaling mechanisms&lt;/strong>. It is particularly useful in &lt;strong>cloud computing, microservices architectures, and dynamic performance modeling&lt;/strong>.&lt;/p>
&lt;p>This model allows for:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Predicting workload changes&lt;/strong> and adjusting resources accordingly.&lt;/li>
&lt;li>&lt;strong>Reducing latency&lt;/strong> by dynamically adapting queue processing.&lt;/li>
&lt;li>&lt;strong>Ensuring scalability&lt;/strong> using PID-based autoscaling.&lt;/li>
&lt;/ol>
&lt;p>Using these equations, performance engineers can &lt;strong>simulate, optimize, and manage&lt;/strong> complex distributed systems dynamically.&lt;/p>
&lt;h2 id="code">Code&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">matplotlib.pyplot&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">plt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">scipy.integrate&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">odeint&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">numpy&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">np&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">matplotlib.pyplot&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">plt&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Global variables&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">time&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">integral&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">time_prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mf">1e-6&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">e_prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The function below calculates the value of manipulated variable (MV) based on the measured value (in example it is the temperature of the liquid) and setpoint value (temperature we want to obtain).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">PID&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Kp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Ki&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Kd&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">setpoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">measurement&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">global&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">integral&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">time_prev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">e_prev&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># Value of offset - when the error is equal zero&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">offset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">320&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># PID calculations&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">setpoint&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">measurement&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">P&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Kp&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">e&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">integral&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">integral&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Ki&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">time_prev&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">D&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Kd&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">e_prev&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">time_prev&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># calculate manipulated variable - MV &lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">MV&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">offset&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">P&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">integral&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">D&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># update stored data for next iteration&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">e_prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">e&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time_prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">MV&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">system&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">Tq&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">epsilon&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tau&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Tf&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">300&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Q&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dTdt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tau&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">epsilon&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">Tf&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">Q&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">epsilon&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Tq&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">temp&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">dTdt&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">tspan&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">linspace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">50&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Tq&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">320&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">sol&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">odeint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">300&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tspan&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">Tq&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tfirst&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">xlabel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Time&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ylabel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Temperature&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">plot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tspan&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">sol&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># number of steps&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">250&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">time_prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">y0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">300&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">deltat&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">y_sol&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">y0&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">t_sol&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">time_prev&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Tq is chosen as a manipulated variable&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">Tq&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">320&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">q_sol&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">Tq&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">setpoint&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">310&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">integral&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">deltat&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">tspan&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">np&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">linspace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time_prev&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Tq&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">PID&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mf">0.6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mf">0.1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">setpoint&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y_sol&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">yi&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">odeint&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">system&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">y_sol&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="n">tspan&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">args&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Tq&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tfirst&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">t_sol&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">y_sol&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">yi&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">q_sol&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Tq&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">time_prev&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">plot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">t_sol&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">y_sol&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">xlabel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Time&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ylabel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Temperature&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>